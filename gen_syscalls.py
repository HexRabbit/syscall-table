import subprocess
import re, json, ctags, sys
from ctags import CTags, TagEntry
from pathlib import Path

if len(sys.argv) < 2:
    print(f'usage: {__file__} [linux_source_path]')
    sys.exit(0)

linux = Path(sys.argv[1]).expanduser()
linux_kernel = linux / 'kernel'
if not (linux / 'kernel').exists():
    print('Not a valid kernel path')
    sys.exit(0)

linux_version = subprocess.check_output('make kernelversion', cwd=linux, shell=True).decode().strip()
if 'rc' in linux_version:
    matched = re.search(r'(\d*\.\d*)\.\d*-rc(\d*)', linux_version)
    linux_version = f'v{matched.group(1)}-rc{matched.group(2)}'

print(linux_version)
# file generated by ctags --fields=afmikKlnsStz --c-kinds=+pc -R
tagfile = linux / 'tags'
if not tagfile.exists():
    print('first generate ctags file by:')
    print('ctags --fields=afmikKlnsStz --c-kinds=+pc -R')
    sys.exit(0)

tags = CTags(str(tagfile))
entry = TagEntry()
syscall_func = []

def parse_line(entry):
    file_name = entry['file'].decode()
    line_num = int(entry['lineNumber'])
    syscall_str = entry['pattern'][2:-2].decode()

    if syscall_str[-1] != ')':
        with open(linux / file_name, 'r') as f:
            start = False
            for i, line in enumerate(f):
                if i == line_num:
                    start = True
                if start:
                    line = line.strip()
                    syscall_str += line
                    if line[-1] == ')':
                        break

    match = re.search(r'SYSCALL_DEFINE(_COMPAT)?\d\((.*)\)', syscall_str)
    symbols = list(map(str.strip, match.group(2).split(',')[1:]))
    params = []
    for i in range(len(symbols)//2):
        params.append({
            'type': symbols[i*2] + ' ' + symbols[i*2+1],
            'def': None
        })

    return params + [{}]*(6-len(params))

syscall_tbl = open(linux / 'arch/x86/entry/syscalls/syscall_64.tbl', 'r')
for line in syscall_tbl.readlines():
    line = line.strip()
    if line:
        if line.startswith('#'):
            continue
        else:
            syscall = re.search(r'(\d*)\s*(\w*)\s*(\w*)\s*(compat_)?(sys_)?(x32_)?(\w*)', line)
            symbols = syscall.groups()
            func_id = int(symbols[0])
            func_type = symbols[1]
            func_name = symbols[2]
            func_fullname = symbols[6] if symbols[6] else 'not implemented'

            # fill the entry
            tags.find(entry, b'SYSCALL_DEFINE', ctags.TAG_PARTIALMATCH)

            while True:
                filepath = entry['file']

                # '[,\)]' is essential to filter mmap2 or the like
                if re.search(r'SYSCALL_DEFINE(_COMPAT)?\d\('+func_fullname+r'[,\)]', entry['pattern'].decode()) \
                    and not (filepath.startswith(b'arch/') and not filepath.startswith(b'arch/x86')):

                    parsed = parse_line(entry)
                    syscall_info = [
                        func_id,
                        func_name,
                        '{0:#04x}'.format(func_id)
                    ]
                    syscall_info += parsed
                    syscall_info += [entry['file'].decode(), entry['lineNumber']]
                    syscall_func.append(syscall_info)
                    break

                elif not tags.findNext(entry):
                    # print(func_name)
                    syscall_func.append([
                        func_id,
                        func_name,
                        '{0:#04x}'.format(func_id),
                        {},
                        {},
                        {},
                        {},
                        {},
                        {},
                        '',
                        0
                    ])
                    break

syscall_tbl.close()

with open('www/syscall.json', 'w+') as f:
    f.write(
        json.dumps(
        {
            'aaData': syscall_func
        },
        sort_keys=True,
        indent=2
    ))

with open('www/index.html.template', 'r') as f:
    html = f.read()
    html = html.replace('__LINUX_VERSION__', linux_version)

with open('www/index.html', 'w+') as f:
    f.write(html)
